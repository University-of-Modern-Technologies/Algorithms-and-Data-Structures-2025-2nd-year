import heapq  # Імпортуємо модуль heapq для реалізації двійкової купи (binary heap)


def heap_sort(
    nums: list, descending: bool = False
) -> list:  # O(n log n) - часова складність
    """
    Сортування масиву за допомогою купи (heap sort).
    Перший підхід: використовує зміну знаку чисел для сортування у зворотному порядку.
    """
    # Визначаємо множник: -1 для сортування за спаданням, 1 за зростанням
    sign = -1 if descending else 1

    # Створюємо копію вхідного масиву, щоб не змінювати оригінал
    iterable = nums[:]  # O(n) - копіювання масиву

    # Змінюємо знак чисел, якщо потрібно сортувати за спаданням
    # Це дозволяє використовувати min-heap для отримання max-heap поведінки
    iterable = [sign * num for num in iterable]  # O(n) - перетворення масиву

    # Перетворюємо список у купу (heap) - O(n) операція
    heapq.heapify(iterable)

    # Витягуємо елементи по одному з купи, повертаючи їх у правильний порядок
    # Кожна операція heappop займає O(log n), повторюється n разів
    return [sign * heapq.heappop(iterable) for _ in range(len(iterable))]  # O(n log n)


def heap_sort_modify(nums: list, descending: bool = False) -> list:  # O(n log n)
    """
    Модифікований підхід до сортування купою.
    Другий підхід: спочатку сортуємо за зростанням, потім реверсуємо якщо потрібно.
    """
    # Створюємо копію вхідного масиву, щоб не змінювати оригінал
    iterable = nums[:]  # O(n) - копіювання масиву

    # Перетворюємо список у мінімальну купу (min-heap) - O(n) операція
    heapq.heapify(iterable)

    # Витягуємо всі елементи з купи по черзі
    # Це дає відсортований масив за зростанням
    result = [heapq.heappop(iterable) for _ in range(len(iterable))]  # O(n log n)

    # Повертаємо результат як є (за зростанням) або реверсований (за спаданням)
    # Реверсування займає O(n) часу
    return result if not descending else result[::-1]


if __name__ == "__main__":
    # Головний блок для тестування обох реалізацій сортування купою
    print("Heap sort")

    # Тестовий масив з різними числами (включно з від'ємними та дублікатами)
    nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
    print("Оригінальний масив:", nums)

    # Тестуємо першу реалізацію (зміна знаку для зворотного сортування)
    print("\n--- heap_sort (перший підхід) ---")
    print("Сортування за зростанням:", heap_sort(nums))
    print("Сортування за спаданням:", heap_sort(nums, True))

    # Тестуємо другу реалізацію (реверсування результату)
    print("\n--- heap_sort_modify (другий підхід) ---")
    print("Сортування за зростанням:", heap_sort_modify(nums))
    print("Сортування за спаданням:", heap_sort_modify(nums, True))
