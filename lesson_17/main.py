"""
ОСНОВНІ ОПЕРАЦІЇ З КУПАМИ (HEAP)

Демонстрація базових операцій з heapq модулем Python.
heapq реалізує min heap - купу де найменший елемент завжди на вершині.
"""

import heapq

# =============================================================================
# ПРИКЛАД 1: Створення MIN HEAP
# =============================================================================

numbers = [4, 10, 3, 5, 1]

# heapify() - перетворює звичайний список в купу (min heap)
# Складність: O(n) - швидше ніж додавати елементи по одному
# ДЛЯ ЧОГО: ініціалізація купи з існуючих даних
# РЕЗУЛЬТАТ: [1, 4, 3, 5, 10] - найменший елемент (1) на позиції [0]
heapq.heapify(numbers)
print("Min heap:", numbers)

# =============================================================================
# ПРИКЛАД 2: Створення MAX HEAP (через інверсію)
# =============================================================================

numbers = [4, 10, 3, 5, 1]

# Python має тільки min heap, але ми можемо зробити max heap через мінус
# КРОК 1: інвертуємо всі числа (множимо на -1)
# ЧОМУ: -4 стає мінімумом у min heap, але це максимум для наших даних
temp_numbers = [el * -1 for el in numbers]  # [-4, -10, -3, -5, -1]

# КРОК 2: створюємо min heap з інвертованих чисел
heapq.heapify(temp_numbers)  # [-10, -5, -3, -4, -1]

# КРОК 3: повертаємо назад (інвертуємо ще раз)
# РЕЗУЛЬТАТ: [10, 5, 3, 4, 1] - найбільший елемент (10) на позиції [0]
numbers = [el * -1 for el in temp_numbers]
print("Max heap:", numbers)

# =============================================================================
# ПРИКЛАД 3: Основні операції з купою
# =============================================================================

numbers = [4, 10, 3, 5, 1]

# Створюємо min heap
heapq.heapify(numbers)  # [1, 4, 3, 5, 10]

# heappush() - додає елемент і зберігає властивості купи
# Складність: O(log n)
# ЧОМУ log n: елемент "спливає" вгору по рівнях дерева
# ДЛЯ ЧОГО: ефективне додавання без пересортування всього масиву
heapq.heappush(numbers, 23)  # Додали 23
heapq.heappush(numbers, 2)  # Додали 2 (стане другим найменшим)
print("Після додавання:", numbers)
print("Вершина:", numbers[0])
# heappop() - видаляє і повертає найменший елемент (вершину)
# Складність: O(log n)
# ЧОМУ log n: останній елемент переміщується на вершину і "просіюється" вниз
# ДЛЯ ЧОГО: отримати і обробити елемент з найвищим пріоритетом
min_element = heapq.heappop(numbers)  # Витягли 1
print("Витягнутий мінімум:", min_element)
print("Купа після видалення:", numbers)

# =============================================================================
# ПРИКЛАД 4: Комбіновані операції
# =============================================================================

# heappushpop() - додає елемент, потім видаляє і повертає найменший
# Складність: O(log n) - швидше ніж окремо push + pop
# ЧОМУ швидше: за одну операцію, без зайвих перестановок
# КОЛИ ВИКОРИСТОВУВАТИ: коли потрібно додати елемент і одразу взяти мінімум
# ПРИКЛАД: підтримка купи фіксованого розміру
min_element = heapq.heappushpop(numbers, 13)  # Додали 13, витягли мінімум
print("heappushpop(13), повернуло:", min_element)
print("Купа після heappushpop:", numbers)

# heapreplace() - видаляє мінімум, потім додає новий елемент
# Складність: O(log n)
# РІЗНИЦЯ з heappushpop: СПОЧАТКУ видаляє, ПОТІМ додає
# ЧОМУ важливо: якщо новий елемент менший за поточний мінімум, він буде видалений відразу
# КОЛИ ВИКОРИСТОВУВАТИ: заміна елементів у купі фіксованого розміру
min_element = heapq.heapreplace(numbers, 1)  # Видалили мінімум, додали 1
print("heapreplace(1), повернуло:", min_element)
print("Купа після heapreplace:", numbers)

# =============================================================================
# ПРИКЛАД 5: Пошук N найменших/найбільших елементів
# =============================================================================

# nsmallest() - повертає N найменших елементів (відсортовані)
# Складність: O(n log k), де k - кількість елементів для пошуку
# ЧОМУ не просто sort: ефективніше коли k << n (шукаємо мало елементів)
# ДЛЯ ЧОГО: топ-N запитів без повного сортування
# ВАЖЛИВО: купа НЕ змінюється
two_min = heapq.nsmallest(2, numbers)  # 2 найменші
print("2 найменші:", two_min, "| Купа:", numbers)

# nlargest() - повертає N найбільших елементів (відсортовані за спаданням)
# Складність: O(n log k)
# ВИКОРИСТАННЯ: рейтинги, топ результатів, найгірші/найкращі показники
two_max = heapq.nlargest(2, numbers)  # 2 найбільші
print("2 найбільші:", two_max, "| Купа:", numbers)
