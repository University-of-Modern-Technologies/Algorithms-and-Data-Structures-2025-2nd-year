# Тема 3. Зв'язані та двозв'язні списки

## Опис заняття
Зв'язані списки. Вставка нового вузла у список. Пошук вузлів. Видалення вузлів. Повний приклад. Двозв'язні списки. Додавання вузлів. Видалення вузла. Пошук вузла за значенням. Приклад використання.

## Файли заняття

### `linked_list_old.py`
Базова реалізація зв'язного списку без оптимізацій:
- `insert_at_end` працює за O(n) - проходить через весь список
- Немає атрибуту `tail`, що ускладнює роботу з кінцем списку
- Базові операції вставки, пошуку та видалення

### `linked_list.py`
Покращена реалізація зв'язного списку з підтримкою tail-вказівника для оптимізації операцій:
- Додано атрибут `tail` для швидкого доступу до кінця списку
- `insert_at_end` тепер працює за O(1) замість O(n)
- Правильне управління `tail` при вставці та видаленні вузлів
- Покращена обробка крайніх випадків при видаленні останнього елемента

### `example.py`
Демонстрація використання декоратора `@lru_cache` - показує як двозв'язні списки застосовуються у реальних алгоритмах кешування для ефективного управління порядком елементів.

### `double_list.py`
Реалізація двозв'язного списку (doubly linked list) з усіма основними операціями:
- Додавання вузлів на початок і кінець списку
- Видалення вузлів за значенням або позицією
- Пошук вузлів за значенням
- Виведення списку в прямому і зворотному порядку

## Рекомендації для студентів
1. Почніть з `linked_list_old.py` - базової реалізації для розуміння основних концепцій
2. Перейдіть до `linked_list.py` - щоб побачити оптимізації з tail-вказівником
3. Зверніть увагу на різницю в складності операцій між двома версіями
4. Перегляньте `example.py` - демонструє практичне застосування двозв'язних списків у LRU кеші
5. Освойте `double_list.py` - щоб зрозуміти як реалізувати двозв'язні списки для алгоритмів
