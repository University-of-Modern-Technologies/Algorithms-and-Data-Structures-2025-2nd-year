class Item:
    """Клас для представлення предмета з вагою і вартістю"""

    def __init__(self, weight, value):
        self.weight = weight
        self.value = value


def knap_sack_memo(W, items, n, memo=None):  # O(n*W), але якщо W константа → O(n)
    """
    Оптимізоване рішення задачі про рюкзак з МЕМОЇЗАЦІЄЮ.
    Замість повторних обчислень одних і тих же підзадач — кешуємо результати.

    Чому це швидше: без кешу ми багато разів рахуємо одну й ту саму пару (n, W).
    З кешем кожна унікальна пара обчислюється лише 1 раз!

    W: залишкова місткість рюкзака
    items: список предметів
    n: скільки предметів ще розглядаємо
    memo: словник для збереження вже обчислених результатів
    """
    # Ініціалізуємо словник для кешування при першому виклику
    if memo is None:
        memo = {}

    # Створюємо ключ для поточного стану (n предметів, W місткості)
    key = (n, W)

    # ГОЛОВНА ІДЕЯ: якщо вже рахували цю пару — просто повертаємо готовий результат
    # Це і економить час — не робимо повторну рекурсію
    if key in memo:
        return memo[key]

    # Базовий випадок: закінчились предмети або місце
    if n == 0 or W == 0:
        return 0

    # Якщо поточний предмет не влазить — пропускаємо
    if items[n - 1].weight > W:
        result = knap_sack_memo(W, items, n - 1, memo)
    else:
        # Розглядаємо обидва варіанти: взяти або не взяти
        take_item = items[n - 1].value + knap_sack_memo(
            W - items[n - 1].weight, items, n - 1, memo
        )
        skip_item = knap_sack_memo(W, items, n - 1, memo)
        result = max(take_item, skip_item)

    # ЗБЕРІГАЄМО результат в кеш перед поверненням
    # Наступного разу з такими ж (n, W) не будемо рахувати знову
    memo[key] = result
    return result


# предмети
items = [Item(10, 60), Item(20, 100), Item(30, 120)]
# місткість рюкзака
capacity = 50
# кількість предметів
n = len(items)
# викликаємо функцію (з мемоїзацією)
print(knap_sack_memo(capacity, items, n))  # 220
