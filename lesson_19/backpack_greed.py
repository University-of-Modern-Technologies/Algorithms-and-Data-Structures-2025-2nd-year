class Item:
    """Клас для представлення предмета з вагою, вартістю та коефіцієнтом ефективності"""

    def __init__(self, weight, value):
        self.weight = weight
        self.value = value
        # ratio = цінність на одиницю ваги (ефективність предмета)
        self.ratio = value / weight


def knap_sack(items: list[Item], capacity: int) -> int:
    """
    ЖАДІБНИЙ алгоритм для задачі про рюкзак.
    O(n log n) через сортування

    УВАГА: цей підхід НЕ ГАРАНТУЄ оптимального рішення для 0/1 knapsack!
    Жадібний алгоритм працює оптимально тільки для fractional knapsack
    (коли можна брати частини предметів).

    Ідея: беремо спочатку найбільш "ефективні" предмети (найбільше value/weight).
    Це інтуїтивно, але не завжди дає найкращий результат.
    """
    # Сортуємо за спаданням ефективності (найкращі спочатку)
    # Це і є "жадібна" стратегія — беремо що виглядає найкраще прямо зараз
    items.sort(key=lambda x: x.ratio, reverse=True)
    # Виводимо відсортований список
    print([(item.ratio, item.weight, item.value) for item in items])
    total_value = 0

    # Проходимось по відсортованому списку і беремо все що влазить
    for item in items:
        if capacity >= item.weight:
            # Якщо предмет влазить — берем його повністю
            capacity -= item.weight
            total_value += item.value
        # Якщо не влазить — пропускаємо і йдемо до наступного предмета

    # ПРОБЛЕМА жадібного підходу: рано взявши "ефективний" предмет,
    # ми можемо заблокувати простір для кількох менш ефективних предметів,
    # які разом дали б більшу вартість, навіть з трохи меншим ratio

    return total_value


if __name__ == "__main__":
    # Дані предметів
    items = [Item(10, 60), Item(20, 100), Item(30, 120)]
    # Місткість рюкзака
    capacity = 50
    # Виклик функції
    print(knap_sack(items, capacity))  # 160
