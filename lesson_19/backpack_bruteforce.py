class Item:
    """Клас для представлення предмета з вагою і вартістю"""

    def __init__(self, weight, value):
        self.weight = weight
        self.value = value


def knap_sack(W, items, n):  # O(2^n) - перебираємо всі 2^n комбінацій
    """
    Брутфорс рішення задачі про рюкзак (0/1 knapsack).
    Перевіряємо ВСІ можливі комбінації предметів рекурсивно.

    W: залишкова місткість рюкзака
    items: список предметів
    n: скільки предметів ще розглядаємо (рухаємось з кінця списку)
    """
    # Базовий випадок: закінчились предмети або місце в рюкзаку
    if n == 0 or W == 0:
        return 0

    # Якщо поточний предмет не влазить — просто пропускаємо його
    if items[n - 1].weight > W:
        return knap_sack(W, items, n - 1)

    # Якщо влазить — розглядаємо ДВА варіанти:
    # Варіант 1: БЕРЕМО предмет — додаємо його вартість і зменшуємо місткість
    take_item = items[n - 1].value + knap_sack(W - items[n - 1].weight, items, n - 1)
    # Варіант 2: НЕ БЕРЕМО предмет — залишаємо місткість без змін
    skip_item = knap_sack(W, items, n - 1)

    # Повертаємо КРАЩИЙ з двох варіантів
    # Це і є причина експоненційної складності — на кожному кроці розгалуження на 2
    return max(take_item, skip_item)


# предмети
items = [Item(10, 60), Item(20, 100), Item(30, 120)]
# місткість рюкзака
capacity = 50
# кількість предметів
n = len(items)
# викликаємо функцію
print(knap_sack(capacity, items, n))  # 220
