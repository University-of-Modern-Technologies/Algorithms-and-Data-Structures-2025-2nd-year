# Універсальне хешування - Детальне пояснення

## Зміст
1. [Що таке хеш-таблиця](#що-таке-хеш-таблиця)
2. [Проблема простих хеш-функцій](#проблема-простих-хеш-функцій)
3. [Рішення: Універсальне хешування](#рішення-універсальне-хешування)
4. [Математика](#математика)
5. [Приклад обчислень](#приклад-обчислень)
6. [Чому це працює](#чому-це-працює)
7. [Код](#код)

---

## Що таке хеш-таблиця

### Аналогія: Шафа з ящиками

Уяви **шафу з 10 ящиками** (пронумеровані 0-9). Тобі треба розкласти **1000 книжок** з номерами від 1 до 1000.

**Питання:** Як швидко знайти книжку №567?

**Варіант 1 (погано):** Шукати послідовно - довго, O(n)

**Варіант 2 (добре):** Використати правило, яке каже "книжка 567 лежить в ящику 7" - швидко, O(1)

Це правило і є **хеш-функція**.

---

## Проблема простих хеш-функцій

### Приклад поганої функції

**Правило:** "Візьми останню цифру номера"

```
h(x) = x % 10
```

**Результат:**
```
Книжка 345 → 345 % 10 = 5 → ящик 5
Книжка 765 → 765 % 10 = 5 → ящик 5  ← КОЛІЗІЯ!
Книжка 985 → 985 % 10 = 5 → ящик 5  ← Ще колізія!
```

### Дві проблеми

**1. Нерівномірний розподіл**

Якщо всі номери закінчуються на 5 (105, 115, 125...), то:
- Ящик 5 переповнений (100 книжок)
- Інші ящики порожні

**2. Атака противника**

Якщо хтось знає твоє правило (`x % 10`), він може спеціально давати номери 5, 15, 25, 35... щоб завалити один ящик і зламати швидкість твоєї системи.

**Приклад атаки:**
```python
# Противник знає що h(x) = x % 10
# Він посилає ключі: 1, 11, 21, 31, 41, 51, 61...
# Всі потраплять в ящик 1 → O(n) замість O(1)
```

---

## Рішення: Універсальне хешування

### Основна ідея

**Замість однієї фіксованої функції** → **випадково вибрати функцію з великого сімейства**

Це як кинути кубик перед грою - противник не може передбачити результат!

### Формула

```
h(x) = ((a × x + b) mod p) mod m
```

Де:
- **x** - ключ (номер книжки)
- **m** - кількість ящиків (наприклад, 10)
- **p** - просте число більше за максимальний ключ
- **a, b** - випадкові числа, вибрані один раз:
  - a ∈ [1, p-1] (не може бути 0!)
  - b ∈ [0, p-1]

### Процес

**Крок 1:** При створенні таблиці - кидаємо "кубики"
```python
hasher = UniversalHashFunction(m=10, max_key=1000)
# Випадково вибрало: p=1009, a=734, b=215
```

**Крок 2:** Використовуємо ці числа для всіх ключів
```python
hasher.hash(345)  # використовує a=734, b=215
hasher.hash(765)  # ті самі a, b
```

---

## Математика

### Чому mod p, потім mod m?

**Два кроки для безпеки:**

**1. `(a × x + b) mod p`** - перше перемішування
- Використовуємо просте число p
- Результат: число від 0 до p-1

**2. `(результат) mod m`** - зведення до розміру таблиці
- m - кількість ящиків
- Результат: число від 0 до m-1 (номер ящика)

### Чому p має бути простим?

Прості числа мають особливу властивість: операції `mod p` добре "перемішують" числа.

**Приклад:**
- p=10 (не просте): 2×5 mod 10 = 0, 4×5 mod 10 = 0 → багато нулів
- p=11 (просте): 2×5 mod 11 = 10, 4×5 mod 11 = 9 → різні значення

---

## Приклад обчислень

### Налаштування

```
m = 10           (10 ящиків)
max_key = 1000   (книжки від 1 до 1000)
p = 1009         (наступне просте після 1000)
a = 734          (випадково вибрано)
b = 215          (випадково вибрано)
```

### Книжка №345

```
h(345) = ((734 × 345 + 215) mod 1009) mod 10

Крок 1: 734 × 345 = 253230
Крок 2: 253230 + 215 = 253445
Крок 3: 253445 mod 1009 = 251  (ділимо 253445 на 1009, залишок 251)
Крок 4: 251 mod 10 = 1

→ Ящик 1
```

### Книжка №765

```
h(765) = ((734 × 765 + 215) mod 1009) mod 10

Крок 1: 734 × 765 = 561510
Крок 2: 561510 + 215 = 561725
Крок 3: 561725 mod 1009 = 677
Крок 4: 677 mod 10 = 7

→ Ящик 7
```

### Книжка №985

```
h(985) = ((734 × 985 + 215) mod 1009) mod 10

Крок 1: 734 × 985 = 722990
Крок 2: 722990 + 215 = 723205
Крок 3: 723205 mod 1009 = 282
Крок 4: 282 mod 10 = 2

→ Ящик 2
```

**Результат:** 345, 765, 985 → ящики 1, 7, 2 (всі різні!)

Порівняй з простим `x % 10`: 345→5, 765→5, 985→5 (всі однакові!)

---

## Чому це працює

### 1. Непередбачуваність

Противник **не знає a і b**, тому не може підібрати колізії.

```
Противник бачить:
  h(123) = 4
  h(456) = 8
  h(789) = 2

Але не може відтворити формулу без знання a і b!
```

### 2. Математична гарантія

**Теорема:** Для будь-яких двох різних ключів x ≠ y:

```
P(h(x) = h(y)) ≤ 1/m
```

Де P - ймовірність колізії.

**Що це означає:**
- m=10 → ймовірність колізії ≤ 10%
- m=100 → ймовірність колізії ≤ 1%
- m=1000 → ймовірність колізії ≤ 0.1%

Це **мінімально можлива** ймовірність для хеш-функції!

### 3. Рівномірний розподіл

Завдяки випадковим a, b та простому p, ключі рівномірно розподіляються по ящиках.

**Приклад з кодом:**
```python
# 1000 випадкових ключів, 10 ящиків
# Очікуємо: ~100 ключів на ящик

Ящик 0: 98  ████████████
Ящик 1: 103 █████████████
Ящик 2: 95  ████████████
Ящик 3: 101 █████████████
...
```

---

## Код

### Створення хеш-функції

```python
from hash_table import UniversalHashFunction

# Створюємо функцію для 10 ящиків, ключі до 1000
hasher = UniversalHashFunction(m=10, max_key=1000)

print(f"Параметри:")
print(f"  p = {hasher.p}")    # наприклад, 1009
print(f"  a = {hasher.a}")    # наприклад, 734
print(f"  b = {hasher.b}")    # наприклад, 215
```

### Використання

```python
# Хешуємо ключі
print(hasher.hash(345))  # → 1
print(hasher.hash(765))  # → 7
print(hasher.hash(985))  # → 2

# Той самий ключ завжди дає той самий результат
print(hasher.hash(345))  # → 1 (так само)
print(hasher.hash(345))  # → 1 (так само)
```

### Нова функція = нові a, b

```python
# Створюємо НОВУ функцію
hasher2 = UniversalHashFunction(m=10, max_key=1000)

# Нові a, b → інші результати!
print(hasher2.hash(345))  # → можливо 9 (інше число)
```

---

## Порівняння з іншими методами

| Метод | Безпека | Швидкість | Ймовірність колізії |
|-------|---------|-----------|---------------------|
| `x % m` | ✗ Погано (атаки) | ✓ O(1) | Висока |
| Криптографічний хеш (SHA256) | ✓✓✓ Відмінно | ✗ Повільно | Дуже низька |
| Універсальний хеш | ✓✓ Добре | ✓ O(1) | ≤ 1/m (оптимально) |

---

## Практичні застосування

1. **Хеш-таблиці (словники)** - Python dict, Java HashMap
2. **Кеші** - збереження результатів обчислень
3. **Балансування навантаження** - розподіл запитів по серверах
4. **Bloom filters** - перевірка існування елемента
5. **Захист від DoS атак** - непередбачуване хешування

---

## Підсумок

**Універсальне хешування = випадковість + математика**

✅ Вибираємо функцію випадково (a, b)
✅ Противник не може атакувати (не знає a, b)
✅ Математично гарантована ймовірність колізії ≤ 1/m
✅ Швидко: O(1) операцій

**Це золота середина між безпекою та швидкістю!**
