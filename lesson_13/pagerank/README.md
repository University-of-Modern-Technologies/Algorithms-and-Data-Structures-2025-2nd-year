# Алгоритм PageRank

## Вступ
PageRank — це алгоритм аналізу посилань, розроблений Ларрі Пейджем та Сергієм Бріном (засновники Google), який використовується для оцінки важливості вузлів у графі. Спочатку він був створений для ранжування веб-сторінок у пошуковій видачі, базуючись на структурі гіперпосилань.

Основна ідея полягає в тому, що "важливі" сторінки частіше посилаються на інші "важливі" сторінки. Сторінка отримує високий ранг, якщо на неї посилається багато інших сторінок або якщо на неї посилаються сторінки з високим рангом.

## Математична модель

### Формула PageRank
Для орієнтованого графа $G = (V, E)$, ранг $PR(u)$ вершини $u$ визначається рекурсивно:

$$ PR(u) = \frac{1 - d}{N} + d \sum_{v \in B(u)} \frac{PR(v)}{L(v)} $$

Де:
- $PR(u)$ — PageRank вершини $u$.
- $PR(v)$ — PageRank вершини $v$, яка посилається на $u$.
- $B(u)$ — множина вершин, що посилаються на $u$ (Backlinks).
- $L(v)$ — кількість вихідних посилань з вершини $v$.
- $N$ — загальна кількість вершин у графі.
- $d$ — **коефіцієнт згасання (damping factor)**, зазвичай $d = 0.85$.

### Коефіцієнт згасання (Damping Factor)
Коефіцієнт $d$ моделює поведінку "випадкового серфера", який з ймовірністю $d$ клікає на посилання на сторінці, а з ймовірністю $1-d$ припиняє клікати й переходить на випадкову сторінку в Інтернеті. Це запобігає застряганню в "пастках" (групах сторінок без вихідних посилань).

## Ітераційний алгоритм (Power Method)
Оскільки значення PageRank залежить від рангу інших сторінок, розв'язок знаходять ітеративно:

1. **Ініціалізація**: Всім вершинам присвоюється початкове значення $1/N$.
2. **Ітерація**: На кожному кроці $k$ оновлюємо ранги всіх вершин за формулою.
3. **Збіжність**: Процес повторюється, доки зміна значень між ітераціями не стане меншою за певний поріг $\epsilon$ (наприклад, $10^{-6}$).

## Реалізація в NetworkX
Функція `nx.pagerank(G, alpha=0.85)` виконує ці обчислення.
- Параметр `alpha` відповідає коефіцієнту $d$.
- Повертає словник, де ключі — вершини, а значення — їхній нормалізований ранг (сума всіх рангів дорівнює 1).

## Приклад з коду
У файлі `main.py` розглядається граф:
- **Ребра**: A→B, A→C, B→C, C→A, D→C.
- Вершина **C** має багато вхідних посилань (від A, B, D), тому очікується, що її ранг буде найвищим.
- Вершина **D** не має вхідних посилань, тому її ранг буде мінімальним (визначається лише базовим значенням $\frac{1-d}{N}$).

## Застосування
- **Пошукові системи**: Ранжування результатів.
- **Соціальні мережі**: Пошук впливових користувачів або рекомендація друзів.
- **Біологія**: Аналіз взаємодії білків.
- **Рекомендаційні системи**: Визначення важливості товарів на основі переходів користувачів.

