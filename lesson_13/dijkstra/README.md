# Алгоритм Дейкстри (Dijkstra's Algorithm)

## Теоретичні основи
Алгоритм Дейкстри — це класичний алгоритм для знаходження найкоротших шляхів від однієї вершини (джерела) до всіх інших вершин у графі з **невід'ємними вагами** ребер. Це приклад **жадібного алгоритму**: на кожному кроці він вибирає "найкращий" локальний варіант (найближчу невідвідану вершину), що в підсумку призводить до глобального оптимуму.

## Принцип роботи: Релаксація ребер
Ключовою операцією є **релаксація**. Якщо ми знаємо відстань до вершини $u$ ($D[u]$) і є ребро $(u, v)$ з вагою $w$, ми перевіряємо, чи можемо ми покращити шлях до $v$, пройшовши через $u$:

$$ \text{Якщо } D[u] + w(u, v) < D[v], \text{ то } D[v] = D[u] + w(u, v) $$

## Детальний алгоритм
1. **Ініціалізація**:
   - Відстань до початкової вершини $S$: $D[S] = 0$.
   - Відстань до всіх інших вершин: $D[v] = \infty$.
   - Створити пріоритетну чергу (Priority Queue) $Q$ і додати туди $S$.
   
2. **Основний цикл**:
   - Поки $Q$ не порожня, витягти вершину $u$ з найменшою відстанню $D[u]$.
   - Якщо $u$ вже була оброблена (знайдено коротший шлях раніше), пропустити.
   - Для кожного сусіда $v$ вершини $u$:
     - Виконати релаксацію: якщо $D[u] + w(u, v) < D[v]$, оновити $D[v]$.
     - Додати (або оновити) $v$ у $Q$ з новим пріоритетом $D[v]$.

## Складність
Залежить від структури даних для пріоритетної черги:
1. **Масив (лінійний пошук мінімуму):** $O(V^2)$. Оптимально для щільних графів, де $E \approx V^2$.
2. **Бінарна купа (Binary Heap):** $O((V + E) \log V)$. Найпоширеніша реалізація (використовується в `heapq` Python).
3. **Купа Фібоначчі:** $O(E + V \log V)$. Теоретично найшвидша, але складна в реалізації і має великі константи, тому рідко використовується на практиці.

## Чому не працюють від'ємні ваги?
Дейкстра припускає, що додавання ребра ніколи не зменшує загальну пройдену відстань. Якщо є від'ємні ваги, "жадібний" вибір найближчої вершини може бути помилковим, оскільки довший шлях може раптом стати коротшим через від'ємне ребро в майбутньому.
Для графів з від'ємними вагами використовують алгоритм **Беллмана-Форда**.

## Реалізація в прикладі
Файл `dijkstra.py` демонструє "наївну" реалізацію з пошуком мінімуму в списку ($O(V^2)$), що є зрозумілішим для навчання.
Файл `visualize_dijkstra.py` використовує оптимізовану бібліотечну функцію `nx.single_source_dijkstra_path`, яка базується на купі.
