# Lesson 10: Хеш-таблиці та хеш-функції

Цей урок присвячений хеш-таблицям, хеш-функціям та їх практичному застосуванню.

## Зміст

### Основи хеш-таблиць

**`example01.py`** - Пошук у списку (O(n))

- Лінійний пошук в телефонній книзі
- Демонстрація повільного пошуку O(n)

**`example02.py`** - Пошук у словнику (O(1))

- Використання вбудованого dict Python
- Швидкий пошук O(1) через хеш-таблицю

**`example03.py`** - Вбудована функція hash()

- Як працює hash() для рядків і чисел
- Детермінізм хеш-функцій
- Перетворення хешу в індекс через операцію % (modulo)

**`example04.py`** - Колізії в хеш-таблиці

- Розподіл ключів по таблиці
- Виявлення колізій (коли два ключі отримують один індекс)
- Візуалізація розподілу

### Реалізація хеш-таблиці

**`example05.py`** - Хеш-таблиця з методом ланцюжків (Chaining)

- Повна реалізація SimpleHashTable
- Методи: `put()`, `get()`, `delete()`
- Використання `defaultdict` для зберігання ланцюжків
- O-нотація: Average O(1), Worst O(n)

**`example05a.py`** - Хеш-таблиця з відкритою адресацією (Linear Probing)

- Реалізація LinearProbingTable
- Лінійне зондування для вирішення колізій
- Візуалізація колізій та зсувів
- Показ хеш-індексів та зсувів при колізіях

### Застосування хеш-таблиць

**`example06.py`** - Перевірка унікальності елементів

- Використання set для пошуку дублікатів
- Порівняння довжин списку та множини
- O(n) складність

### Криптографічні хеш-функції

**`example07.py`** - Робота з hashlib

- Створення об'єкту хешування
- Метод `.update()` для додавання даних
- `.hexdigest()` для отримання результату
- Детермінізм хеш-функцій

**`example08.py`** - Лавинний ефект

- Демонстрація SHA-256
- Як мала зміна входу повністю змінює хеш

**`example09.py`** - Порівняння хеш-алгоритмів

- MD5, SHA-1, SHA-256, SHA-512, BLAKE2b, SHA3-256
- Довжини хешів та їх безпека
- Список всіх доступних алгоритмів у hashlib

**`hashlib.md`** - Детальна документація

- Опис кожного алгоритму хешування
- Історія та характеристики
- Чому MD5 та SHA-1 небезпечні (rainbow tables, колізії)
- Порівняльна таблиця
- Рекомендації щодо використання

### Безпечне зберігання паролів

**`example10.py`** - PBKDF2-HMAC для паролів

- Хешування паролів з salt
- 100,000 ітерацій для сповільнення
- Процес реєстрації та перевірки логіну
- Вимірювання часу виконання
- Чому важливі ітерації та salt

**`example11.py`** - Bcrypt для паролів

- Використання бібліотеки bcrypt
- Автоматичний salt (вбудований у хеш)
- Cost factor (раунди хешування)
- Порівняння швидкості з різними cost factors

**`example12.py`** - Argon2 для паролів

- Найсучасніший алгоритм для паролів (переможець конкурсу 2015)
- Параметри: time_cost, memory_cost, parallelism
- Порівняння з bcrypt
- Вимірювання часу

### Практичне застосування

**`example13.py`** - Перевірка цілісності файлів

- Обчислення хешу файлу (MD5)
- Читання файлів частинами (chunked reading)
- Порівняння файлів через хеші
- Виявлення змін у файлах

## Встановлення

```bash
# Створення віртуального оточення
python -m venv .venv

# Активація (Windows PowerShell)
.\.venv\Scripts\Activate.ps1

# Встановлення залежностей
pip install -r requirements.txt
```

## Ключові концепції

### Хеш-таблиця

- Структура даних для швидкого пошуку O(1)
- Використовує хеш-функцію для перетворення ключа в індекс
- Вирішення колізій: ланцюжки (chaining) або відкрита адресація (open addressing)

### Колізії

- Виникають коли різні ключі мають однаковий хеш
- **Метод ланцюжків**: зберігаємо список елементів у кожному індексі
- **Лінійне зондування**: шукаємо наступний вільний слот

### Криптографічні хеш-функції

- **Односпрямованість**: неможливо відновити вхід з хешу
- **Лавинний ефект**: мала зміна входу → повна зміна хешу
- **Стійкість до колізій**: складно знайти два входи з однаковим хешем
