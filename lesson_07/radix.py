def radix_sort(arr):
    # Якщо масив порожній то немає чого сортувати
    if not arr:
        return []

    # Знаходимо максимальне число щоб знати скільки існує розрядів
    max_num = max(arr)

    # Починаємо із наймолодшого розряду (одиниці)
    pos = 1

    # Поки існує хоч один елемент із цим розрядом
    while max_num // pos > 0:

        # Масив лічильників для цифр 0..9
        count = [0] * 10

        # Тимчасовий вихідний масив такого самого розміру що й arr
        out = [0] * len(arr)

        # Рахуємо скільки разів кожна цифра зʼявляється у даному розряді
        # Наприклад для pos = 1 беремо останню цифру
        # (x // pos) % 10 виділяє цифру у потрібному розряді
        for x in arr:
            d = (x // pos) % 10
            count[d] += 1

        # Перетворюємо кількість входжень у накопичувану суму
        # count[d] після цього означає куди ставити наступний елемент з цифрою d
        for d in range(1, 10):
            count[d] += count[d - 1]

        # Будуємо вихідний масив з кінця
        # Це необхідно для стабільності сортування
        # Якщо дві цифри однакові то їх первинний порядок зберігається
        for i in range(len(arr) - 1, -1, -1):
            d = (arr[i] // pos) % 10
            count[d] -= 1
            out[count[d]] = arr[i]

        # Переписуємо результат назад у вихідний масив
        # Тепер дані відсортовані по цьому розряду
        for i in range(len(arr)):
            arr[i] = out[i]

        # Переходимо до наступного старшого розряду
        pos *= 10


# Перевірка роботи алгоритму
arr = [3, 89, 67, 254, 9, 21, 185, 4, 62]
radix_sort(arr)  # in-place
print("Відсортований масив", arr)
